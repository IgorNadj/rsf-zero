import path from "path";
import fs from "fs";
import {
  CompilerOptions,
  createProgram,
  flattenDiagnosticMessageText,
  ModuleKind,
} from "typescript";
import {Action} from "../types.js";
import md5 from "md5";
import * as os from "node:os";
import {extname} from "../utils/extname.js";
import {asRelativeImport} from "../utils/asRelativeImport.js";


export const buildServerFiles = (actions: Action[], rootDir: string) => {
  if (actions.length > 0) {
    const serverOutDir = path.join(rootDir, 'dist/server');
    const srcDir = path.join(rootDir, 'src');

    // Create tmp directory
    const tmpDir = os.tmpdir();
    const projectHash = md5(process.cwd());
    const generatedRegistryFilePath = path.join(tmpDir, `rsf-zero-registry-${projectHash}.ts`);

    const compilerOptions: CompilerOptions = {
      strict: true,
      module: ModuleKind.ESNext,
      allowSyntheticDefaultImports: true,
      skipLibCheck: true,
      rewriteRelativeImportExtensions: true,
      outDir: serverOutDir,
      rootDir: srcDir,
    };

    // Clear outDir before starting
    fs.rmSync(serverOutDir, { recursive: true });

    // Generate registry ts file
    const registryContent = generateActionRegistryTs(actions, generatedRegistryFilePath);
    fs.writeFileSync(generatedRegistryFilePath, registryContent);

    // Create TypeScript program with the temporary file as entry point
    const program = createProgram([generatedRegistryFilePath], compilerOptions);

    // Emit the compiled files
    const emitResult = program.emit();

    // Check for compilation errors
    const allDiagnostics = program.getSemanticDiagnostics()
      .concat(program.getSyntacticDiagnostics())
      .concat(emitResult.diagnostics);

    if (allDiagnostics.length > 0) {
      allDiagnostics.forEach(diagnostic => {
        if (diagnostic.file) {
          const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);
          const message = flattenDiagnosticMessageText(diagnostic.messageText, '\n');
          console.error(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
        } else {
          console.error(flattenDiagnosticMessageText(diagnostic.messageText, '\n'));
        }
      });

      if (emitResult.emitSkipped) {
        throw new Error('TypeScript compilation failed');
      }
    }

    // Finally, create a js version of the generated registry file
    // - we do this because the ts version is in /tmp as not not pollute the user's app src
    //   - the other option being to place the ts version in the user's src/
    // - it's a simple file, so we can make it manually without needing to use tsc
    fs.writeFileSync(path.join(serverOutDir, 'actionRegistry.js'), generateActionRegistryJs(actions, srcDir));

    console.log(`RSF-Zero build with ${actions.length} action${actions.length === 1 ? '' : 's'} success. Start with rsf-zero start.`);
  }
}

/**
 * Create a typescript file that imports all actions. This can then be passed to a tsc to be processed into dist js files.
 */
function generateActionRegistryTs(actions: Action[], registryPath: string): string {
  const actionsWithRelativePaths = actions.map(action => {
    return {
      ...action,
      relativeSourceFilePath: asRelativeImport(action.sourceFilePath, registryPath),
    };
  })

  return `// Generated by RSF Zero, do not modify

${actionsWithRelativePaths.map(action => `import { ${action.name} } from '${action.relativeSourceFilePath}';`).join('\n')}

export const actionRegistry = {
  ${actions.map(action => `"${action.name}": ${action.name}`).join('\n')}
};
`;
}



/**
 * Create a javascript file that imports all actions. This is used by the start command to load action functions when the server starts.
 */
function generateActionRegistryJs(actions: Action[], relativeToDir: string): string {
  const actionsWithRelativePaths = actions.map(action => {
    return {
      ...action,
      relativeSourceFilePath: asRelativeImport(action.sourceFilePath, relativeToDir, '.js'),
    };
  })

  return `// Generated by RSF Zero, do not modify

${actionsWithRelativePaths.map(action => `import { ${action.name} } from '${action.relativeSourceFilePath}';`).join('\n')}

export const actionRegistry = {
  ${actions.map(action => `"${action.name}": ${action.name}`).join('\n')}
};
`;
}
