import path from "path";
import fs from "fs";
import {
  CompilerOptions,
  createProgram,
  flattenDiagnosticMessageText,
  ModuleKind,
  ScriptTarget
} from "typescript";
import {Action} from "../types.js";
import {tmpdir} from "node:os";
import md5 from "md5";


export const buildServerFiles = (actions: Action[], rootDir: string) => {
  if (actions.length > 0) {
    const serverOutDir = path.join(rootDir, 'dist/server');

    // Ensure output directory exists
    if (!fs.existsSync(serverOutDir)) {
      fs.mkdirSync(serverOutDir, { recursive: true });
    }

    const compilerOptions: CompilerOptions = {
      strict: true,
      module: ModuleKind.ESNext,
      allowSyntheticDefaultImports: true,
      skipLibCheck: true,
      rewriteRelativeImportExtensions: true,
      outDir: serverOutDir,
    };

    // Clear outDir before starting
    fs.rmSync(serverOutDir, { recursive: true });

    // Generate registry file in the src directory
    const generatedFilesDir = rootDir + '/src/generated';
    if (!fs.existsSync(generatedFilesDir)) {
      fs.mkdirSync(generatedFilesDir, { recursive: true });
    }
    const generatedRegistryFilePath = `${generatedFilesDir}/registry.ts`;
    console.log('Creating generated registry file for build: ', generatedRegistryFilePath);
    const registryContent = generateActionRegistryTS(actions, generatedRegistryFilePath);
    fs.writeFileSync(generatedRegistryFilePath, registryContent);

    // Create TypeScript program with the temporary file as entry point
    const program = createProgram([generatedRegistryFilePath], compilerOptions);

    // Emit the compiled files
    const emitResult = program.emit();

    // Check for compilation errors
    const allDiagnostics = program.getSemanticDiagnostics()
      .concat(program.getSyntacticDiagnostics())
      .concat(emitResult.diagnostics);

    if (allDiagnostics.length > 0) {
      allDiagnostics.forEach(diagnostic => {
        if (diagnostic.file) {
          const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);
          const message = flattenDiagnosticMessageText(diagnostic.messageText, '\n');
          console.error(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
        } else {
          console.error(flattenDiagnosticMessageText(diagnostic.messageText, '\n'));
        }
      });

      if (emitResult.emitSkipped) {
        throw new Error('TypeScript compilation failed');
      }
    }

    console.log(`Built ${actions.length} server files and registry to ${serverOutDir}`);
  }
}

function generateActionRegistryTS(actions: Action[], registryPath: string): string {
  // Get relative paths for imports from the registry
  const actionsWithRelativePaths = actions.map(action => {
    return {
      ...action,
      relativeSourceFilePath: path.relative(path.dirname(registryPath), action.sourceFilePath),
    };
  })

  return `// Generated by RSF Zero, do not modify

${actionsWithRelativePaths.map(action => `import { ${action.name} } from '${action.relativeSourceFilePath}';`).join('\n')}

export const actionRegistry = {
  ${actions.map(action => `"${action.name}": ${action.name}`).join('\n')}
};
`;
}
